(load "git@github.com:carpentry-org/uri@0.0.4")
(load "git@github.com:carpentry-org/time@0.0.4")

(deftype Cookie [name String,
                 value String,
                 path String,
                 expires Datetime,
                 domain String,
                 secure Bool,
                 http-only Bool,
                 extension String])

(defmodule Cookie
  (defn expired? [c] (> &(Datetime.now) (expires c)))
)

(deftype Request [verb String,
                  version String,
                  uri URI,
                  cookies (Array Cookie),
                  headers (Map String (Array String)),
                  body String])

(defmodule Request
  (doc ignore-body? "checks whether the body of the request should be ignored.")
  (defn ignore-body? [r] (= (verb r) "HEAD"))

  (private str-headers)
  (hidden str-headers)
  (defn str-headers [r]
    (Map.kv-reduce
      &(fn [acc k v]
        (fmt "%s\r\n%s"
             &acc
             &(String.join "\r\n" &(Array.copy-map &(fn [x] (fmt "%s: %s" k x)) v))
        ))
      @""
      (headers r)))

  (doc str "stringifies the request. It should be stringified exactly as it
looks on the wire.")
  (defn str [r]
    (fmt "%s %s %s%s\r\n\r\n%s"
         (verb r)
         &(str (uri r))
         (version r)
         &(str-headers r)
         (body r)))

  ; TODO: restrict this to \r\n
  (private rn-lines)
  (hidden rn-lines)
  (defn rn-lines [s]
    (let-do [pat #"\n"
             ns &(Pattern.substitute pat s "\n" -1)
             idx (Pattern.find-all pat ns)
             lidx (Array.length &idx)
             result (Array.allocate (Int.inc lidx))]
      (Array.aset-uninitialized! &result 0
        (substring ns 0 (if (> lidx 0) @(Array.unsafe-nth &idx 0) (length ns))))
      (for [i 0 (Int.dec (Array.length &idx))]
        (Array.aset-uninitialized! &result (Int.inc i)
          (substring ns (Int.inc @(Array.unsafe-nth &idx i)) @(Array.unsafe-nth &idx (Int.inc i)))))
      (when (> lidx 0)
        (Array.aset-uninitialized! &result lidx
          (suffix-string ns (Int.inc @(Array.unsafe-nth &idx (Int.dec lidx))))))
      result))

  ; TODO: parse cookies
  (doc parse "parses a HTTP request from a string `txt`.

Returns a `(Error String)` if it fails.")
  (defn parse [txt]
    (let [ls &(rn-lines txt)
          fst (Array.first ls)]
      (match fst
        (Maybe.Nothing) (Result.Error @"Malformed request: empty")
        (Maybe.Just s)
          (let [splt (String.words &s)]
            (if (/= (Array.length &splt) 3)
              (Result.Error (fmt "Malformed request: found first line '%s'" &s))
              (let-do [headers {}
                       body @""
                       failed @""]
                (for [i 1 (Array.length ls)]
                  (let [l (Array.unsafe-nth ls i)]
                    (if (= l "")
                      (do
                        (when (> (Array.length ls) (Int.inc i))
                          (set! body
                            (String.join "\n"
                                         &(Array.suffix-array ls (Int.inc i)))))
                        (break))
                      (let [splt (String.split-by l &[\:])]
                        (if (< (Array.length &splt) 2)
                          (do
                            (set! failed @l)
                            (break))
                          (let [k (Array.nth &splt 0)
                                v &(String.trim &(String.join ":" &(Array.suffix-array &splt 1)))]
                            (set! headers
                              (Map.update-with-default
                                headers
                                (Array.unsafe-nth &splt 0)
                                &(fn [h] (Array.push-back h @v))
                                []))))))))
                (if (/= &failed "")
                  (Result.Error (fmt "Malformed request: found header '%s'" &failed))
                  (let [uri (URI.parse (Array.unsafe-nth &splt 1))]
                    (match uri
                      (Result.Success uri)
                        (Result.Success
                          (Request.init
                            @(Array.unsafe-nth &splt 0)
                            @(Array.unsafe-nth &splt 2)
                            uri
                            []
                            headers
                            body))
                      (Result.Error err)
                        (Result.Error
                          (fmt "Malformed request: uri decoding error: '%s'" &err)))))))))))
)
